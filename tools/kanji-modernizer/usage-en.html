<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-57QT78M3JB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-57QT78M3JB');
</script>


  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>How to Use | Kanji Modernizer</title>
    <meta name="description" content="Detailed guide for the Old ‚áÑ Modern Kanji converter. Conversion rules, dictionary size, notes, and privacy explained.">
    <meta name="keywords" content="kyujitai, shinjitai, old kanji, modern kanji, japanese kanji converter, variant glyphs, ivs, unicode">

    <meta property="og:type" content="article">
    <meta property="og:title" content="How to Use the Old ‚áÑ Modern Kanji Converter | NicheWorks">
    <meta property="og:description" content="How to use the Old ‚áÑ Modern Kanji converter: conversion directions, precautions, dictionary size, and privacy.">
    <meta property="og:image" content="https://nicheworks.pages.dev/assets/og-kanji.png">

  <link rel="icon" href="/assets/favicon.ico">
  <link rel="apple-touch-icon" href="/assets/favicon.ico">
  <link rel="stylesheet" href="./style.css">
<script defer
  src="https://static.cloudflareinsights.com/beacon.min.js"
  data-cf-beacon='{"token": "aeec938336694c99bc864cdf859b5e37"}'>
</script>
</head>

  <body>
    <header class="nw-header">
      <h1 class="nw-title">Kanji Modernizer ‚Äì Usage Guide</h1>
      <p class="nw-subtitle">Features, conversion rules, privacy, and tips.</p>
    </header>

  <div class="ad-slot ad-top">Ad placeholder (preparing)</div>

  <main class="nw-main">

    <a href="./index.html" class="usage-back">‚Üê Back to Tool</a>

    <section class="usage-section">
      <h2>Old-style kanji explained</h2>
      <p>Old-style kanji (Ky≈´jitai) are the pre-reform glyphs based on the Kangxi Dictionary forms and were widely used in books, newspapers, and official documents through the pre-war era. After 1946, Japan introduced simplified forms (Shinjitai) via the T≈çy≈ç Kanji list, which became today‚Äôs standard shapes.</p>
      <p>Because of historical usage and personal preferences, old forms still appear in family registers, resident records, placenames, shrine/temple names, monuments, and classical documents. Systems that assume only modern forms may fail to recognize these characters, so conversion support is often necessary.</p>
      <p>Unicode also distinguishes certain variant glyphs using Ideographic Variation Sequences (IVS). Without IVS-capable fonts, some variants may look identical, so be mindful of visual differences versus underlying code points.</p>
    </section>

    <section class="usage-section">
      <h2>1. What does this tool do?</h2>
      <p>
        Converts Old Kanji (Ëàä„ÉªÂ≠∏„ÉªÈ´î etc.) into Modern Kanji,
        and converts Modern Kanji back into their Old forms.
        All processing is done locally in your browser.
      </p>
    </section>

    <section class="usage-section">
      <h2>2. Conversion directions</h2>
      <ul>
        <li><b>Old ‚Üí Modern</b>: Convert traditional forms into simplified ones.</li>
        <li><b>Modern ‚Üí Old</b>: Convert simplified forms into traditional kanji. When multiple candidates exist, the first one in the dictionary is used.</li>
      </ul>
    </section>

    <section class="usage-section">
      <h2>3. How to use</h2>
      <ol>
        <li>Select conversion direction</li>
        <li>Paste text in the input box</li>
        <li>Press ‚ÄúConvert‚Äù</li>
        <li>Copy the output</li>
      </ol>
    </section>

    <section class="usage-section">
      <h2>4. Dictionary size</h2>
      <p>The latest dictionary is loaded automatically and shown below.</p>
      <ul>
        <li>Old ‚Üí Modern: <b data-count="old">--</b> characters</li>
        <li>Modern ‚Üí Old: <b data-count="new">--</b> characters</li>
        <li>Total unique: <b data-count="unique">--</b></li>
      </ul>
    </section>

    <section class="usage-section">
      <h2>5. Privacy</h2>
      <p>No data is uploaded. 100% client-side.</p>
    </section>

    <section class="usage-section">
      <h2>6. Notes</h2>
      <ul>
        <li>Some rare variants (Kangxi forms) are not included.</li>
        <li>Modern ‚Üí Old picks the most common traditional form.</li>
        <li>Special family-name variants are converted only if present in the dictionary.</li>
      </ul>
    </section>

    <div class="nw-donate">
      <p>If this tool helps, please consider supporting via OFUSE / Ko-fi.</p>
      <div class="nw-donate-links">
        <a href="https://ofuse.me/nicheworks" target="_blank">üíå OFUSE</a>
        <a href="https://ko-fi.com/nicheworks" target="_blank">‚òï Ko-fi</a>
      </div>
    </div>

    <div class="nw-links">
      <a href="/tools/rename-wizard/">Rename Wizard</a> /
      <a href="/tools/log-formatter/">LogFormatter</a> /
      <a href="/tools/filetype-sniffer/">FileType Sniffer</a>
    </div>
  </main>

  <footer class="nw-footer">
    <p>¬© 2025 NicheWorks</p>
  </footer>

  <script>
    function normalizeChar(val) {
      return typeof val === "string" ? val.normalize("NFC") : "";
    }

    function rebuildDict(raw) {
      const normalizedOldToNew = {};
      const normalizedNewToOld = {};

      const rawOldToNew = raw && typeof raw === "object" ? raw.old_to_new || {} : {};
      Object.keys(rawOldToNew).forEach(key => {
        const nKey = normalizeChar(key);
        const nVal = normalizeChar(rawOldToNew[key]);
        if (!nKey || !nVal) return;
        if (Object.prototype.hasOwnProperty.call(normalizedOldToNew, nKey)) return;
        normalizedOldToNew[nKey] = nVal;
      });

      const rawNewToOld = raw && typeof raw === "object" ? raw.new_to_old || {} : {};
      Object.keys(rawNewToOld).forEach(key => {
        const nKey = normalizeChar(key);
        if (!nKey) return;
        const values = Array.isArray(rawNewToOld[key]) ? rawNewToOld[key] : [rawNewToOld[key]];
        const normalizedValues = [];

        values.forEach(v => {
          const nVal = normalizeChar(v);
          if (!nVal) return;
          if (!normalizedValues.includes(nVal)) {
            normalizedValues.push(nVal);
          }
        });

        if (normalizedValues.length === 0) return;
        if (!normalizedNewToOld[nKey]) {
          normalizedNewToOld[nKey] = [];
        }
        normalizedValues.forEach(v => {
          if (!normalizedNewToOld[nKey].includes(v)) {
            normalizedNewToOld[nKey].push(v);
          }
        });
      });

      return { old_to_new: normalizedOldToNew, new_to_old: normalizedNewToOld };
    }

    document.addEventListener("DOMContentLoaded", async () => {
      try {
        const res = await fetch("./dict.json", { cache: "no-store" });
        if (!res.ok) return;
        const rawDict = await res.json();
        const dict = rebuildDict(rawDict);
        const oldCount = Object.keys(dict.old_to_new || {}).length;
        const newCount = Object.keys(dict.new_to_old || {}).length;
        const uniqueCount = new Set([
          ...Object.keys(dict.old_to_new || {}),
          ...Object.keys(dict.new_to_old || {})
        ]).size;

        document.querySelectorAll('[data-count="old"]').forEach(el => {
          el.textContent = oldCount;
        });
        document.querySelectorAll('[data-count="new"]').forEach(el => {
          el.textContent = newCount;
        });
        document.querySelectorAll('[data-count="unique"]').forEach(el => {
          el.textContent = uniqueCount;
        });
      } catch (e) {
        console.error(e);
      }
    });
  </script>
</body>
</html>
